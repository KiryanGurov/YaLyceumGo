# Введение

На этом курсе вы уже изучили основы Go, познакомились со многими языковыми конструкциями и решили немало заданий. Теперь пора проверить эти знания на практике и написать действительно масштабный и приближенный к реальным задачам код. Материалы для сегодняшнего занятия подготовила специально для вас команда Яндекс Такси!

**Реальная ситуация**. Каждый день сервис Яндекс Такси обрабатывает миллионы поездок. Цена каждой из них рассчитывается индивидуально с учётом десятков факторов. В 2023 году система динамического ценообразования Яндекса обрабатывала до 10,000 запросов в секунду в пиковые часы.

**Что будем делать**. Создадим упрощённую модель системы ценообразования, которая будет учитывать его ключевые факторы. В реальной системе используется машинное обучение и сложные алгоритмы, а мы разберём базовые принципы работы сервиса.

# Архитектура решения

Наша система будет состоять из нескольких компонентов:

1. Модуль расчёта базовой цены
2. Модуль учёта временных коэффициентов
3. Модуль учёта погодных условий
4. Модуль учёта загруженности дорог
5. Модуль агрегации всех факторов

Разделение кода на модули — это фундаментальный принцип проектирования программного обеспечения, который особенно важен в крупных компаниях. В больших проектах с миллионами строк кода, над которыми работают тысячи разработчиков, как в Яндексе, этот вопрос встаёт наиболее остро.

Вот почему это критически важно:

1. Упрощение поддержки и чтения кода

**Проблема без модулей**. Если бы весь код был в одной функции, её было бы сложно анализировать и изменять (например, если добавить новый коэффициент).

**Как в Яндексе**. В реальных сервисах такси код может обновляться несколько раз в день, и модульность ускоряет этот процесс.

2. Изоляция ответственности

**Проблема без модулей**. При ошибке в расчёте погодных коэффициентов нужно будет также проверять код, связанный с временными коэффициентами, если их логика завязана друг на друге.

**Как в Яндексе**. В компаниях типа Яндекса большинство инцидентов решаются быстрее благодаря чёткому разделению зон ответственности.

3. Возможность тестирования компонентов

**Проблема без модулей**. Фрагменты кода очень тяжело протестировать по отдельности, если при написании тестов неясно, какая часть кода за что отвечает.

**Как в Яндексе**. В Яндексе тесты запускаются перед каждым деплоем (загрузкой программы на открытый для клиентов сервер) — это снижает количество багов в продакшене.

4. Гибкость при изменениях

**Проблема без модулей**. Если появится необходимость учитывать новые данные (например, температуру воздуха), а код не разделён на модули, придётся переписывать всю функцию расчёта цены, рискуя повредить другие компоненты.

**Как в Яндексе**. В такси-сервисах требования меняются еженедельно, и модульность позволяет адаптироваться без полного рефакторинга и изменения кодовой базы.

5. Повторное использование кода

**Проблема без модулей**. Тяжело переиспользовать отдельные функции или компоненты, если они сильно связаны. Для этого придётся переписывать код с нуля или сильно видоизменять предыдущий, вынося часть компонентов отдельно, что приведёт к сильным временным затратам и возможным ошибкам.

**Как в Яндексе**. В Яндексе такие модули сразу выносят в отдельные библиотеки (пакеты).

Конечно, причин выносить код в отдельные модули намного больше, но мы упомянули основные из них. Переходим к разработке нашей программы!

# Базовая цена: фундамент расчётов

**Зачем.** Прежде чем добавлять коэффициенты, нужно понять стоимость поездки в идеальных условиях. В Яндекс Такси это называется тарифная сетка.

**Интересный факт.** В реальной системе базовые тарифы — разные для каждого города и типа автомобиля (эконом, комфорт, бизнес). Например, в Москве тарифы выше, чем в регионах.


Ограничение времени	60 секунд

Ограничение памяти	1524 Мб

Ввод	стандартный ввод или main.go

Вывод	стандартный вывод

Напишите программу, которая рассчитывает базовую тарифную сетку для нашего проекта.

Для этого реализуйте структуру `TripParameters` с полями `Distance (float64)` и `Duration (float64)`. Также реализуйте функцию `CalculateBasePrice`, которая рассчитывает базовую цену по формуле: `Distance * pricePerKm + Duration * pricePerMinute`. Значения `pricePerKm` и `pricePerMinute` вынесите в константы с соответствующими значениями `10.0` и `2.0`.

### Примечания

Программа должна находиться в пакете `main` для тестирования.

## Базовая цена — решение

``` go
const (
	pricePerKm     = 10.0
	pricePerMinute = 2.0
)

type TripParameters struct {
	Distance float64
	Duration float64
}

func CalculateBasePrice(trip TripParameters)float64 {
	return trip.Distance*pricePerKm + trip.Duration*pricePerMinute
}
```

# Временные коэффициенты: учёт «часа пик»

**Зачем.** В утренний час пик спрос превышает предложение, а ночью водители работают в менее комфортных условиях.

**Реальная статистика Яндекса.**

- В будни с 7:00 до 10:00 спрос выше на 40%
- В пятницу вечером коэффициент может достигать 1.8x от базовой цены

``` go
func GetTimeMultiplier(t time.Time) float64 {
    hour := t.Hour()
    isWeekend := t.Weekday() == time.Saturday || t.Weekday() == time.Sunday // Проверка, что сегодня суббота или воскресенье (выходные)

    switch {
    case hour >= 0 && hour < 5:
        return 1.5 // Ночной тариф
    case hour >= 7 && hour < 10 && !isWeekend:
        return 1.3 // Утренний час пик
    case isWeekend:
        return 1.2 // Выходные
    default:
        return 1.0
    }
}
```

**Интересный кейс.** В Новый год с 23:00 до 1:00 Яндексу приходится вручную выставлять коэффициент 3x—5x из-за аномального спроса.

# Погодные коэффициенты: когда все вызывают такси

**Зачем.** При плохой погоде люди чаще пользуются такси вместо пеших прогулок или общественного транспорта.

**Реальные данные Яндекса.**

- Сильный дождь увеличивает спрос на 25–30%
- Снегопад в Москве может увеличить цену на 50%

``` go
type WeatherCondition int

const (
    Clear WeatherCondition = iota // Ключевое слово iota присваивает каждой константе числовое значение по порядку (0, 1, 2, 3 и т.д.)
    Rain
    HeavyRain
    Snow
)

type WeatherData struct {
    Condition WeatherCondition
    WindSpeed int
}
```

## Загруженность дорог — решение

#### Автор курса

``` go
func GetWeatherMultiplier(weather WeatherData) float64 {
    multiplier := 1.0
    
    if weather.Condition == HeavyRain {
        multiplier += 0.2  // Увеличиваем коэффициент в сильный дождь
    } else if weather.Condition == Snow {
        multiplier += 0.15 // Увеличиваем коэффициент в снег
    } else if weather.Condition == Rain {
        multiplier += 0.125 // Увеличиваем коэффициент в дождь
    }
    
    if weather.WindSpeed > 15 {
        multiplier += 0.1  // Увеличиваем коэффициент при сильном ветре
    }
    
    return multiplier
}
```

#### Моё
``` go
func GetWeatherMultiplier(weather WeatherData) float64 {
	var conditionMultiplier = map[WeatherCondition]float64{
		Rain:      0.125,
		HeavyRain: 0.2,
		Snow:      0.15,
	}
	
	res := 1.0 + conditionMultiplier[weather.Condition]
	if weather.WindSpeed > 15 {
		return res + 0.1
	}
	return res
}
```

**Факт.** Яндекс использует данные собственной метеослужбы (Яндекс Погода), которая учитывает микроклимат разных районов города.

# Загруженность дорог: пробки и их стоимость

**Зачем.** В пробках водитель тратит больше времени и бензина, поэтому цена должна это компенсировать.

**Как это работает в Яндексе.**

- Используются данные с 1,000,000+ датчиков и GPS-трекеров
- Уровень загруженности обновляется каждые 30 секунд

``` go
type TrafficClient interface {
    GetTrafficLevel(lat, lng float64) int // 1–5
}

func GetTrafficMultiplier(trafficLevel int) float64 {
    return 1.0 + float64(trafficLevel-1)*0.1
}

type PriceCalculator struct {
    TrafficClient TrafficClient
}

type RealTrafficClient struct{}

func (c *RealTrafficClient) GetTrafficLevel(lat, lng float64) int {
    return 3 // Константное значение в нашем примере, в реальности оно будет вычисляться сервисом Яндекс Карты
}
```

**Кейс.** Во время массовых мероприятий (футбольные матчи, концерты) Яндекс вручную корректирует коэффициенты вокруг мест их проведения.

# Агрегация всех факторов: финальный расчёт

**Зачем.** Нужно объединить все факторы в итоговую цену, понятную пользователю.

**Важно.** В реальной системе Яндекса:

- Расчёт происходит за 50–100 мс
- Пользователь видит округлённое значение
- Цена может измениться несколько раз в течение минуты

``` go
func (c *PriceCalculator) CalculatePrice(trip TripParameters, now time.Time, weather WeatherData, lat, lng float64) float64 {
    base := CalculateBasePrice(trip)
    timeMult := GetTimeMultiplier(now)
    weatherMult := GetWeatherMultiplier(weather)
    trafficMult := GetTrafficMultiplier(c.TrafficClient.GetTrafficLevel(lat, lng))

    finalPrice := base * timeMult * weatherMult * trafficMult

    return ApplyPriceLimits(math.Round(finalPrice))
}
```
**Факт.** Алгоритм динамического ценообразования Яндекса постоянно совершенствуется.

# Ограничения цены: защита от аномалий

**Зачем.** Чтобы избежать:

- Слишком низких цен (убытки)
- Слишком высоких цен (потеря клиентов)

# Ограничение цены

Ограничение времени	60 секунд

Ограничение памяти	1524 Мб

Ввод	стандартный ввод или main.go

Вывод	стандартный вывод

Напишите программу, которая ограничивает максимальную и минимальную цену поездки. Вынесите эти значения в константы `minPrice` и `maxPrice` со значениями `99.0` и `20000`. Саму проверку реализуйте в функции `ApplyPriceLimits(price float64) float64`, которая получает цену и возвращает либо её же, если она входит в ограничения, либо минимальную цену, если меньше, либо максимальную, если больше.

### Примечания

Программа должна находиться в пакете `main` для тестирования.

## Ограничение цены — решение

### Автор курса
``` go
const (
    minPrice = 99.0
    maxPrice = 20000.0
)

func ApplyPriceLimits(price float64) float64 {
    if price < minPrice {
        return minPrice
    }
    if price > maxPrice {
        return maxPrice
    }
    return price
}
```

### Моё решение
``` go
const (
	minPrice = 99.0
	maxPrice = 20000.0
)

func ApplyPriceLimits(price float64) float64 {
	switch {
	case price < minPrice:
		return minPrice
	case price > maxPrice:
		return maxPrice
	default:
		return price
	}
}
```
**Интересно.** Во время урагана в Москве в 2021 году система автоматически ограничила максимальный коэффициент на уровне 3.5x, хотя спрос был выше.

# Интеграция: собираем систему вместе

**Как это работает в Яндексе.**

- Разные команды разрабатывают отдельные модули
- Система сборки проверяет совместимость
- Тестирование проходит на прошлых проверенных данных

``` go
func main() {
    calculator := PriceCalculator{
        TrafficClient: &RealTrafficClient{}, // В продакшене используется настоящий клиент, а мы подключим структуру-заглушку для имитации его работы
    }
    
    price := calculator.CalculatePrice(
        TripParameters{Distance: 8.5, Duration: 20},
        time.Now(),
        WeatherData{HeavyRain, 10},
        55.751244, 37.618423,
    )
    
    fmt.Printf("Ваша цена: %.0f руб.\n", price)
}
```
После запуска проекта с заданными параметрами можно увидеть результат работы нашей программы: Ваша цена: 216 руб.. Предлагаем поэкспериментировать с параметрами и посмотреть, как он меняется в зависимости от различных факторов. Например, если вместо дождя будет снег, цена будет снижена до 207 рублей.

# Деплой и мониторинг

**Реальная практика Яндекса.**

1. Новый алгоритм тестируется на части трафика, то есть не у всех пользователей в приложении сразу включаются новые фичи
2. Сравниваются конверсия и доход, а также огромное множество других важных метрик
3. Если метрики в норме — полный rollout (выкатка на всех пользователей системы)
**Факт.** Выкатка нового кода на часть пользователей называется A/B-тестированием.

# Заключение: что дальше?

В реальной системе Яндекс Такси учитывается намного больше факторов, например:
- Персональные скидки пользователя
- Баланс спроса и предложения в реальном времени
- Сезонные факторы (например, курортный сезон)
- Тип автомобиля
- И т. д.
Вы только что разобрали упрощённую, но вполне рабочую систему динамического ценообразования. Её более сложная и масштабная версия ежедневно помогает варьировать цены в Яндекс Такси, чтобы сделать их честными и оптимальными. Теперь вы понимаете, зачем разбивать код на модули, как учитывать множество внешних факторов и почему сервисы от крупных компаний — это всегда комплексная работа команды специалистов.

Продолжайте экспериментировать, углублять знания и не бойтесь масштабных задач. Возможно, именно ваш код однажды попадёт в продакшен Яндекса и будет влиять на жизнь миллионов пользователей!